{"ast":null,"code":"var _jsxFileName = \"D:\\\\Hossein\\\\2024\\\\Spring\\\\CS529\\\\HW01\\\\CS529_HW01\\\\src\\\\Whitehat.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useMemo } from 'react';\nimport useSVGCanvas from './useSVGCanvas.js';\nimport * as d3 from 'd3';\nimport * as Plot from \"https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm\";\nimport { scaleSequential } from 'd3-scale';\nimport { interpolateViridis } from 'd3-scale-chromatic';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Whitehat(props) {\n  _s();\n  //this is a generic component for plotting a d3 plot\n  const d3Container = useRef(null);\n  //this automatically constructs an svg canvas the size of the parent container (height and width)\n  //tTip automatically attaches a div of the class 'tooltip' if it doesn't already exist\n  //this will automatically resize when the window changes so passing svg to a useeffect will re-trigger\n  const [svg, height, width, tTip] = useSVGCanvas(d3Container);\n  //\\\\turn on zoom in state from false to true\n  var isZoomed = true;\n\n  //TODO: change the line below to change the size of the white-hat maximum bubble size\n  //\\\\change from 100 to 120 to smaller view\n  const maxRadius = width / 120;\n\n  //albers usa projection puts alaska in the corner\n  //this automatically convert latitude and longitude to coordinates on the svg canvas\n  const projection = d3.geoAlbersUsa().translate([width / 2, height / 2]);\n\n  //set up the path generator to draw the states\n  const geoGenerator = d3.geoPath().projection(projection);\n\n  //we need to use this function to convert state names into ids so we can select individual states by name using javascript selectors\n  //since spaces makes it not work correctly\n  function cleanString(string) {\n    return string.replace(' ', '_').replace(' ', '_');\n  }\n  //===============================================\n\n  //This is the main loop that renders the code once the data loads\n  //TODO: edit or replace this code to create your white-hat version of the map view; for example, change the color map based on colorbrewer2, \n  const mapGroupSelection = useMemo(() => {\n    //wait until the svg is rendered and data is loaded\n    if (svg !== undefined & props.map !== undefined & props.data !== undefined) {\n      let populationState = '';\n      const stateData = props.data.states;\n      const citiesData = props.data;\n      console.log(citiesData);\n\n      //EDIT THIS TO CHANGE WHAT IS USED TO ENCODE COLOR\n      const getEncodedFeature = d => d.count;\n\n      //this section of code sets up the colormap\n      const stateCounts = Object.values(stateData).map(getEncodedFeature);\n\n      //get color extends for the color legend\n      const [stateMin, stateMax] = d3.extent(stateCounts);\n\n      //color map scale, scales numbers to a smaller range to use with a d3 color scale\n      //we're using 1-0 to invert the red-yellow-green color scale\n      //so red is bad (p.s. this is not a good color scheme still)\n      const stateScale = d3.scaleSequentialSqrt().domain([stateMin, stateMax]).range([0, 1]);\n\n      //TODO: EDIT HERE TO CHANGE THE COLOR SCHEME\n      //this function takes a number 0-1 and returns a color\n      //\\\\ change color map to blue for better vision blindcolor person\n      const colorMap = d3.scaleSequential(d3.interpolateBlues);\n\n      //this set of functions extracts the features given the state name from the geojson\n      function getCount(name) {\n        //map uses full name, dataset uses abreviations\n        name = cleanString(name);\n        let entry = stateData.filter(d => d.state === name);\n        if (entry === undefined | entry.length < 1) {\n          return 0;\n        }\n        populationState = entry[0].population;\n        return getEncodedFeature(entry[0]);\n      }\n      function getStateVal(name) {\n        let count = getCount(name);\n        let val = stateScale(count);\n        return val;\n      }\n      function getStateColor(d) {\n        return colorMap(getStateVal(d.properties.NAME));\n      }\n\n      //clear earlier drawings\n      svg.selectAll('g').remove();\n\n      //OPTIONAL: EDIT THIS TO CHANGE THE DETAILS OF HOW THE MAP IS DRAWN\n      //draw borders from map and add tooltip\n      let mapGroup = svg.append('g').attr('class', 'mapbox');\n      mapGroup.selectAll('path').filter('.state').data(props.map.features).enter().append('path').attr('class', 'state')\n      //ID is useful if you want to do brushing as it gives you a way to select the path\n      .attr('id', d => cleanString(d.properties.NAME)).attr('d', geoGenerator).attr('fill', getStateColor).attr('stroke', 'black').attr('stroke-width', 0.5).on('mouseover', (e, d) => {\n        let state = cleanString(d.properties.NAME);\n        //this updates the brushed state\n        if (props.brushedState !== state) {\n          props.setBrushedState(state);\n        }\n        let sname = d.properties.NAME;\n        let count = getCount(sname);\n        let text = sname + '</br>' + 'populationState: ' + populationState + \"</br>\" + 'Gun Deaths: ' + count + \"</br>\" + \"Deaths per 1 million: \" + count / populationState * 1000000;\n        tTip.html(text);\n      }).on('mousemove', e => {\n        //see app.js for the helper function that makes this easier\n        props.ToolTip.moveTTipEvent(tTip, e);\n      }).on('mouseout', (e, d) => {\n        props.setBrushedState();\n        props.ToolTip.hideTTip(tTip);\n      });\n\n      //TODO: replace or edit the code below to change the city marker being used. \n      //Hint: think of the cityScale range (perhaps use area rather than radius). \n      //draw markers for each city\n      console.log(\"prpos\");\n      const cityData = props.data.cities;\n      console.log(\"city\");\n      const cityMax = d3.max(cityData.map(d => d.count));\n      const cityScale = d3.scaleRadial().domain([0, cityMax]).range([0, maxRadius]);\n      mapGroup.selectAll('.city').remove();\n\n      //TODO: Add code for a tooltip when you mouse over the city (hint: use the same code for the state tooltip events .on... and modify what is used for the tTip.html)\n      //OPTIONAL: change the color or opacity\n\n      // const cityColorScale = scaleSequential(d3.interpolateGreens)\n      //     .domain([0, cityMax]); // Set the domain based on the data range\n      const cityColorScale = d3.scaleLinear().domain([0, cityMax]).range(['#deebf7', '#3182bd']);\n      mapGroup.selectAll('.city').data(cityData).enter().append('circle').attr('class', 'city').attr('id', d => d.key).attr('cx', d => projection([d.lng, d.lat])[0]).attr('cy', d => projection([d.lng, d.lat])[1]).attr('r', d => cityScale(d.count)).attr('opacity', 2).attr('fill', d => cityColorScale(d.count)).on('mouseover', function (event, d) {\n        // Show tooltip on mouseover\n        tTip.html(`City: ${d.city}<br>Count: ${d.count}`).style('left', `${event.pageX}px`).style('top', `${event.pageY}px`).style('opacity', 0.1);\n      }).on('mouseout', function () {\n        // Hide tooltip on mouseout\n        tTip.style('opacity', 0);\n      }).on('mouseover', (e, d) => {\n        let cityName = d.city;\n        let Citycount = d.count;\n        let text = cityName + '</br>' + 'City Count: ' + Citycount + \"</br>\" + 'State: ' + d.state + \"</br>\";\n        tTip.html(text);\n      }).on('mousemove', e => {\n        props.ToolTip.moveTTipEvent(tTip, e);\n      }).on('mouseout', (e, d) => {\n        props.ToolTip.hideTTip(tTip);\n      });\n      //draw a color legend, automatically scaled based on data extents\n      function drawLegend() {\n        let bounds = mapGroup.node().getBBox();\n        const barHeight = Math.min(height / 5, 50);\n        let legendX = bounds.x + 15 + bounds.width;\n        const barWidth = Math.min((width - legendX) / 3, 40);\n        const fontHeight = Math.min(barWidth / 1, 16);\n        let legendY = bounds.y + 2 * fontHeight;\n        let colorLData = [];\n        //OPTIONAL: EDIT THE VALUES IN THE ARRAY TO CHANGE THE NUMBER OF ITEMS IN THE COLOR LEGEND\n        for (let ratio of [0.01, 0.1, .2, .3, .4, .5, .6, .7, .8, .9, 1]) {\n          let val = (1 - ratio) * stateMin + ratio * stateMax;\n          let scaledVal = stateScale(val);\n          let color = colorMap(scaledVal);\n          let entry = {\n            'x': legendX,\n            'y': legendY,\n            'value': val,\n            'color': color\n          };\n          entry.text = entry.value.toFixed(0);\n          colorLData.push(entry);\n          legendY += barHeight;\n        }\n        svg.selectAll('.legendRect').remove();\n        svg.selectAll('.legendRect').data(colorLData).enter().append('rect').attr('class', 'legendRect').attr('x', d => d.x).attr('y', d => d.y).attr('fill', d => d.color).attr('height', barHeight).attr('width', barWidth);\n        svg.selectAll('.legendText').remove();\n        const legendTitle = {\n          'x': legendX - barWidth,\n          'y': bounds.y + 50\n        };\n        svg.selectAll('.legendText').data([legendTitle].concat(colorLData)).enter().append('text').attr('class', 'legendText').attr('x', d => d.x + barWidth + 5).attr('y', d => d.y + barHeight / 2 + fontHeight / 4).attr('font-size', (d, i) => i == 0 ? 1.2 * fontHeight : fontHeight).text(d => d.text);\n      }\n      drawLegend();\n      return mapGroup;\n    }\n  }, [svg, props.map, props.data]);\n\n  //This adds zooming. Triggers whenever the function above finishes\n  //this section can be included in the main body but is here as an example \n  //of how to do multiple hooks so updates don't have to occur in every state\n  useMemo(() => {\n    if (mapGroupSelection === undefined) {\n      return;\n    }\n\n    //set up zooming\n    function zoomed(event) {\n      const {\n        transform\n      } = event;\n      mapGroupSelection.attr(\"transform\", transform).attr(\"stroke-width\", 1 / transform.k);\n    }\n    const zoom = d3.zoom().on(\"zoom\", zoomed);\n\n    //OPTIONAL: EDIT THIS CODE TO CHANGE WHAT HAPPENS WHEN YOU CLICK A STATE\n    //useful if you want to add brushing\n    function clicked(event, d) {\n      event.stopPropagation();\n      if (isZoomed) {\n        mapGroupSelection.transition().duration(300).call(zoom.transform, d3.zoomIdentity.translate(0, 0), d3.pointer(event, svg.node()));\n      } else {\n        //get bounds of path from map\n        const [[x0, y0], [x1, y1]] = geoGenerator.bounds(d);\n        //zoom to bounds\n        mapGroupSelection.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(Math.min(8, 0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height))).translate(-(x0 + x1) / 2, -(y0 + y1) / 2), d3.pointer(event, svg.node()));\n      }\n      //sets the zoomed state property in the main app when we click on something\n      //if we are zoomed in, unzoom instead\n      isZoomed = !isZoomed;\n      if (isZoomed) {\n        props.setZoomedState(d.properties.NAME);\n      } else {\n        props.setZoomedState(undefined);\n      }\n    }\n    mapGroupSelection.selectAll('.state').attr('cursor', 'pointer') //so we know the states are clickable\n    .on('click', clicked);\n  }, [mapGroupSelection]);\n\n  //OPTIONAL: EDIT HERE TO CHANGE THE BRUSHING BEHAVIOUR IN THE MAP WHEN MOUSING OVER A STATE\n  //WILL UPDATE WHEN THE \"BRUSHEDSTATE\" VARIABLE CHANGES\n  //brush the state by altering it's opacity when the property changes\n  //brushed state can be on the same level but that makes it harder to use in linked views\n  //so its in the parent app to simplify the \"whitehat\" part which uses linked views.\n  useMemo(() => {\n    if (mapGroupSelection !== undefined) {\n      const isBrushed = props.brushedState !== undefined;\n      mapGroupSelection.selectAll('.state').attr('opacity', isBrushed ? .4 : .8).attr('strokeWidth', isBrushed ? 1 : 2);\n      if (isBrushed) {\n        mapGroupSelection.select('#' + props.brushedState).attr('opacity', 1).attr('strokeWidth', 3);\n      }\n    }\n  }, [mapGroupSelection, props.brushedState]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"d3-component\",\n    style: {\n      'height': '99%',\n      'width': '99%'\n    },\n    ref: d3Container\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 319,\n    columnNumber: 9\n  }, this);\n}\n_s(Whitehat, \"IY1z98gdTh246QemP6MlitVdCfk=\", false, function () {\n  return [useSVGCanvas];\n});\n_c = Whitehat;\nvar _c;\n$RefreshReg$(_c, \"Whitehat\");","map":{"version":3,"names":["React","useRef","useMemo","useSVGCanvas","d3","Plot","scaleSequential","interpolateViridis","jsxDEV","_jsxDEV","Whitehat","props","_s","d3Container","svg","height","width","tTip","isZoomed","maxRadius","projection","geoAlbersUsa","translate","geoGenerator","geoPath","cleanString","string","replace","mapGroupSelection","undefined","map","data","populationState","stateData","states","citiesData","console","log","getEncodedFeature","d","count","stateCounts","Object","values","stateMin","stateMax","extent","stateScale","scaleSequentialSqrt","domain","range","colorMap","interpolateBlues","getCount","name","entry","filter","state","length","population","getStateVal","val","getStateColor","properties","NAME","selectAll","remove","mapGroup","append","attr","features","enter","on","e","brushedState","setBrushedState","sname","text","html","ToolTip","moveTTipEvent","hideTTip","cityData","cities","cityMax","max","cityScale","scaleRadial","cityColorScale","scaleLinear","key","lng","lat","event","city","style","pageX","pageY","cityName","Citycount","drawLegend","bounds","node","getBBox","barHeight","Math","min","legendX","x","barWidth","fontHeight","legendY","y","colorLData","ratio","scaledVal","color","value","toFixed","push","legendTitle","concat","i","zoomed","transform","k","zoom","clicked","stopPropagation","transition","duration","call","zoomIdentity","pointer","x0","y0","x1","y1","scale","setZoomedState","isBrushed","select","className","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Hossein/2024/Spring/CS529/HW01/CS529_HW01/src/Whitehat.js"],"sourcesContent":["\r\nimport React, {useRef,useMemo} from 'react';\r\nimport useSVGCanvas from './useSVGCanvas.js';\r\nimport * as d3 from 'd3';\r\nimport * as Plot from \"https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm\";\r\nimport { scaleSequential } from 'd3-scale';\r\nimport { interpolateViridis } from 'd3-scale-chromatic';\r\n\r\n\r\nexport default function Whitehat(props){\r\n    //this is a generic component for plotting a d3 plot\r\n    const d3Container = useRef(null);\r\n    //this automatically constructs an svg canvas the size of the parent container (height and width)\r\n    //tTip automatically attaches a div of the class 'tooltip' if it doesn't already exist\r\n    //this will automatically resize when the window changes so passing svg to a useeffect will re-trigger\r\n    const [svg, height, width, tTip] = useSVGCanvas(d3Container);\r\n    //\\\\turn on zoom in state from false to true\r\n    var isZoomed = true;\r\n\r\n    //TODO: change the line below to change the size of the white-hat maximum bubble size\r\n    //\\\\change from 100 to 120 to smaller view\r\n    const maxRadius = width/120;\r\n\r\n    //albers usa projection puts alaska in the corner\r\n    //this automatically convert latitude and longitude to coordinates on the svg canvas\r\n    const projection = d3.geoAlbersUsa()\r\n        .translate([width/2,height/2]);\r\n\r\n    //set up the path generator to draw the states\r\n    const geoGenerator = d3.geoPath().projection(projection);\r\n\r\n    //we need to use this function to convert state names into ids so we can select individual states by name using javascript selectors\r\n    //since spaces makes it not work correctly\r\n    function cleanString(string){\r\n        return string.replace(' ','_').replace(' ','_')\r\n    }\r\n//===============================================\r\n\r\n    //This is the main loop that renders the code once the data loads\r\n    //TODO: edit or replace this code to create your white-hat version of the map view; for example, change the color map based on colorbrewer2, \r\n    const mapGroupSelection = useMemo(()=>{\r\n        //wait until the svg is rendered and data is loaded\r\n        if(svg !== undefined & props.map !== undefined & props.data !== undefined){\r\n         let populationState = '';\r\n            const stateData = props.data.states;\r\n            const citiesData= props.data;\r\n            console.log(citiesData)\r\n\r\n            //EDIT THIS TO CHANGE WHAT IS USED TO ENCODE COLOR\r\n            const getEncodedFeature = d => d.count\r\n\r\n            //this section of code sets up the colormap\r\n            const stateCounts = Object.values(stateData).map(getEncodedFeature);\r\n\r\n            //get color extends for the color legend\r\n            const [stateMin,stateMax] = d3.extent(stateCounts);\r\n\r\n            //color map scale, scales numbers to a smaller range to use with a d3 color scale\r\n            //we're using 1-0 to invert the red-yellow-green color scale\r\n            //so red is bad (p.s. this is not a good color scheme still)\r\n            const stateScale = d3.scaleSequentialSqrt()\r\n                .domain([stateMin,stateMax])\r\n                .range([0,1]);\r\n\r\n            //TODO: EDIT HERE TO CHANGE THE COLOR SCHEME\r\n            //this function takes a number 0-1 and returns a color\r\n            //\\\\ change color map to blue for better vision blindcolor person\r\n            const colorMap = d3.scaleSequential(d3.interpolateBlues);\r\n              \r\n            //this set of functions extracts the features given the state name from the geojson\r\n            function getCount(name){\r\n                //map uses full name, dataset uses abreviations\r\n                name = cleanString(name);\r\n                let entry = stateData.filter(d=>d.state===name);\r\n                if(entry === undefined | entry.length < 1){\r\n                    return 0\r\n                }\r\n                populationState = entry[0].population;\r\n                return getEncodedFeature(entry[0]);\r\n            }\r\n            function getStateVal(name){\r\n                let count = getCount(name);\r\n                let val = stateScale(count);\r\n                return val\r\n            }\r\n\r\n            function getStateColor(d){\r\n                return colorMap(getStateVal(d.properties.NAME))\r\n            }\r\n\r\n            //clear earlier drawings\r\n            svg.selectAll('g').remove();\r\n\r\n            //OPTIONAL: EDIT THIS TO CHANGE THE DETAILS OF HOW THE MAP IS DRAWN\r\n            //draw borders from map and add tooltip\r\n            let mapGroup = svg.append('g').attr('class','mapbox');\r\n            mapGroup.selectAll('path').filter('.state')\r\n                .data(props.map.features).enter()\r\n                .append('path').attr('class','state')\r\n                //ID is useful if you want to do brushing as it gives you a way to select the path\r\n                .attr('id',d=> cleanString(d.properties.NAME))\r\n                .attr('d',geoGenerator)\r\n                .attr('fill',getStateColor)\r\n                .attr('stroke','black')\r\n                .attr('stroke-width',0.5)\r\n                .on('mouseover',(e,d)=>{\r\n                    let state = cleanString(d.properties.NAME);\r\n                    //this updates the brushed state\r\n                    if(props.brushedState !== state){\r\n                        props.setBrushedState(state);\r\n                    }\r\n                    let sname = d.properties.NAME;\r\n                    let count = getCount(sname); \r\n                    let text = sname + '</br>'\r\n                        + 'populationState: ' + populationState + \"</br>\"\r\n                        + 'Gun Deaths: ' + count + \"</br>\"\r\n                        + \"Deaths per 1 million: \" + (count/populationState)*1000000;\r\n                    tTip.html(text);\r\n                }).on('mousemove',(e)=>{\r\n                    //see app.js for the helper function that makes this easier\r\n                    props.ToolTip.moveTTipEvent(tTip,e);\r\n                }).on('mouseout',(e,d)=>{\r\n                    props.setBrushedState();\r\n                    props.ToolTip.hideTTip(tTip);\r\n                });\r\n\r\n\r\n            //TODO: replace or edit the code below to change the city marker being used. \r\n            //Hint: think of the cityScale range (perhaps use area rather than radius). \r\n            //draw markers for each city\r\n            console.log(\"prpos\")\r\n\r\n            const cityData = props.data.cities\r\n            console.log(\"city\")\r\n            const cityMax = d3.max(cityData.map(d=>d.count));\r\n            const cityScale = d3.scaleRadial()\r\n                .domain([0,cityMax])\r\n                .range([0,maxRadius]);\r\n\r\n            mapGroup.selectAll('.city').remove();\r\n\r\n            //TODO: Add code for a tooltip when you mouse over the city (hint: use the same code for the state tooltip events .on... and modify what is used for the tTip.html)\r\n            //OPTIONAL: change the color or opacity\r\n            \r\n            // const cityColorScale = scaleSequential(d3.interpolateGreens)\r\n            //     .domain([0, cityMax]); // Set the domain based on the data range\r\n            const cityColorScale = d3.scaleLinear()\r\n                .domain([0,cityMax])\r\n                .range(['#deebf7','#3182bd'])\r\n            mapGroup.selectAll('.city')\r\n                .data(cityData).enter()\r\n                .append('circle').attr('class','city')\r\n                .attr('id',d=>d.key)\r\n                .attr('cx',d=> projection([d.lng,d.lat])[0])\r\n                .attr('cy',d=> projection([d.lng,d.lat])[1])\r\n                .attr('r',d=>cityScale(d.count))\r\n                .attr('opacity',2)                \r\n                .attr('fill', d => cityColorScale(d.count))\r\n                .on('mouseover', function (event, d) {\r\n                    // Show tooltip on mouseover\r\n                    tTip.html(`City: ${d.city}<br>Count: ${d.count}`)\r\n                        .style('left', `${event.pageX}px`)\r\n                        .style('top', `${event.pageY}px`)\r\n                        .style('opacity', 0.1);\r\n                })\r\n                .on('mouseout', function () {\r\n                    // Hide tooltip on mouseout\r\n                    tTip.style('opacity', 0);\r\n                })\r\n                .on('mouseover', (e, d) => {\r\n                    let cityName = d.city;\r\n                    let Citycount = d.count;\r\n                    let text = cityName + '</br>' + 'City Count: ' + Citycount+\"</br>\"\r\n                    + 'State: ' + d.state + \"</br>\"\r\n                     \r\n                    tTip.html(text);\r\n                }).on('mousemove', (e) => {\r\n                    props.ToolTip.moveTTipEvent(tTip, e);\r\n                }).on('mouseout', (e, d) => {\r\n                    props.ToolTip.hideTTip(tTip);\r\n                });\r\n            //draw a color legend, automatically scaled based on data extents\r\n            function drawLegend(){\r\n                let bounds = mapGroup.node().getBBox();\r\n                const barHeight = Math.min(height/5,50);\r\n                \r\n                let legendX = bounds.x + 15 + bounds.width;\r\n                const barWidth = Math.min((width - legendX)/3,40);\r\n                const fontHeight = Math.min(barWidth/1,16);\r\n                let legendY = bounds.y + 2*fontHeight;\r\n                \r\n                let colorLData = [];\r\n                //OPTIONAL: EDIT THE VALUES IN THE ARRAY TO CHANGE THE NUMBER OF ITEMS IN THE COLOR LEGEND\r\n                for(let ratio of [0.01,0.1,.2,.3,.4,.5,.6,.7,.8,.9,1]){\r\n                    let val = (1-ratio)*stateMin + ratio*stateMax;\r\n                    let scaledVal = stateScale(val);\r\n                    let color = colorMap(scaledVal);\r\n                    let entry = {\r\n                        'x': legendX,\r\n                        'y': legendY,\r\n                        'value': val,\r\n                        'color':color,\r\n                    }\r\n                    entry.text = (entry.value).toFixed(0);\r\n            \r\n                    colorLData.push(entry);\r\n                    legendY += barHeight;\r\n                }\r\n    \r\n                svg.selectAll('.legendRect').remove();\r\n                svg.selectAll('.legendRect')\r\n                    .data(colorLData).enter()\r\n                    .append('rect').attr('class','legendRect')\r\n                    .attr('x',d=>d.x)\r\n                    .attr('y',d=>d.y)\r\n                    .attr('fill',d=>d.color)\r\n                    .attr('height',barHeight)\r\n                    .attr('width',barWidth);\r\n    \r\n                svg.selectAll('.legendText').remove();\r\n                const legendTitle = {\r\n                    'x': legendX - barWidth,\r\n                    'y': bounds.y + 50,\r\n\r\n                }\r\n                svg.selectAll('.legendText')\r\n                    .data([legendTitle].concat(colorLData)).enter()\r\n                    .append('text').attr('class','legendText')\r\n                    .attr('x',d=>d.x+barWidth+5)\r\n                    .attr('y',d=>d.y+barHeight/2 + fontHeight/4)\r\n                    .attr('font-size',(d,i) => i == 0? 1.2*fontHeight:fontHeight)\r\n                    .text(d=>d.text);\r\n            }\r\n\r\n            drawLegend();\r\n            return mapGroup\r\n        }\r\n    },[svg,props.map,props.data])\r\n\r\n    //This adds zooming. Triggers whenever the function above finishes\r\n    //this section can be included in the main body but is here as an example \r\n    //of how to do multiple hooks so updates don't have to occur in every state\r\n    useMemo(()=>{\r\n        if(mapGroupSelection === undefined){ return }\r\n        \r\n        //set up zooming\r\n        function zoomed(event) {\r\n            const {transform} = event;\r\n            mapGroupSelection\r\n                .attr(\"transform\", transform)\r\n               .attr(\"stroke-width\", 1 / transform.k);\r\n        }\r\n\r\n        const zoom = d3.zoom()\r\n            .on(\"zoom\", zoomed);\r\n\r\n        //OPTIONAL: EDIT THIS CODE TO CHANGE WHAT HAPPENS WHEN YOU CLICK A STATE\r\n        //useful if you want to add brushing\r\n        function clicked(event, d) {\r\n            event.stopPropagation();\r\n            if(isZoomed){\r\n                mapGroupSelection.transition().duration(300).call(\r\n                    zoom.transform,\r\n                    d3.zoomIdentity.translate(0,0),\r\n                    d3.pointer(event,svg.node())\r\n                )\r\n                    \r\n            }\r\n            else{\r\n                //get bounds of path from map\r\n                const [[x0, y0], [x1, y1]] = geoGenerator.bounds(d);\r\n                //zoom to bounds\r\n                mapGroupSelection.transition().duration(750).call(\r\n                    zoom.transform,\r\n                    d3.zoomIdentity\r\n                    .translate(width / 2, height / 2)\r\n                    .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height)))\r\n                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),\r\n                    d3.pointer(event, svg.node())\r\n                );\r\n            }\r\n            //sets the zoomed state property in the main app when we click on something\r\n            //if we are zoomed in, unzoom instead\r\n            isZoomed = !isZoomed;\r\n            if(isZoomed){\r\n                props.setZoomedState(d.properties.NAME);\r\n            } else{\r\n                props.setZoomedState(undefined);\r\n            }\r\n        }\r\n        \r\n\r\n        mapGroupSelection.selectAll('.state')\r\n            .attr('cursor','pointer')//so we know the states are clickable\r\n            .on('click',clicked);\r\n\r\n    },[mapGroupSelection]);\r\n\r\n    //OPTIONAL: EDIT HERE TO CHANGE THE BRUSHING BEHAVIOUR IN THE MAP WHEN MOUSING OVER A STATE\r\n    //WILL UPDATE WHEN THE \"BRUSHEDSTATE\" VARIABLE CHANGES\r\n    //brush the state by altering it's opacity when the property changes\r\n    //brushed state can be on the same level but that makes it harder to use in linked views\r\n    //so its in the parent app to simplify the \"whitehat\" part which uses linked views.\r\n    useMemo(()=>{\r\n        if(mapGroupSelection !== undefined){\r\n            const isBrushed = props.brushedState !== undefined;\r\n            mapGroupSelection.selectAll('.state')\r\n                .attr('opacity',isBrushed? .4:.8)\r\n                .attr('strokeWidth',isBrushed? 1:2);\r\n            if(isBrushed){\r\n                mapGroupSelection.select('#'+props.brushedState)\r\n                    .attr('opacity',1)\r\n                    .attr('strokeWidth',3);\r\n            }\r\n        }\r\n    },[mapGroupSelection,props.brushedState]);\r\n    \r\n    return (\r\n        <div\r\n            className={\"d3-component\"}\r\n            style={{'height':'99%','width':'99%'}}\r\n            ref={d3Container}\r\n        ></div>\r\n    );\r\n}\r\n"],"mappings":";;AACA,OAAOA,KAAK,IAAGC,MAAM,EAACC,OAAO,QAAO,OAAO;AAC3C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAO,KAAKC,EAAE,MAAM,IAAI;AACxB,OAAO,KAAKC,IAAI,MAAM,0DAA0D;AAChF,SAASC,eAAe,QAAQ,UAAU;AAC1C,SAASC,kBAAkB,QAAQ,oBAAoB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAGxD,eAAe,SAASC,QAAQA,CAACC,KAAK,EAAC;EAAAC,EAAA;EACnC;EACA,MAAMC,WAAW,GAAGZ,MAAM,CAAC,IAAI,CAAC;EAChC;EACA;EACA;EACA,MAAM,CAACa,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAEC,IAAI,CAAC,GAAGd,YAAY,CAACU,WAAW,CAAC;EAC5D;EACA,IAAIK,QAAQ,GAAG,IAAI;;EAEnB;EACA;EACA,MAAMC,SAAS,GAAGH,KAAK,GAAC,GAAG;;EAE3B;EACA;EACA,MAAMI,UAAU,GAAGhB,EAAE,CAACiB,YAAY,CAAC,CAAC,CAC/BC,SAAS,CAAC,CAACN,KAAK,GAAC,CAAC,EAACD,MAAM,GAAC,CAAC,CAAC,CAAC;;EAElC;EACA,MAAMQ,YAAY,GAAGnB,EAAE,CAACoB,OAAO,CAAC,CAAC,CAACJ,UAAU,CAACA,UAAU,CAAC;;EAExD;EACA;EACA,SAASK,WAAWA,CAACC,MAAM,EAAC;IACxB,OAAOA,MAAM,CAACC,OAAO,CAAC,GAAG,EAAC,GAAG,CAAC,CAACA,OAAO,CAAC,GAAG,EAAC,GAAG,CAAC;EACnD;EACJ;;EAEI;EACA;EACA,MAAMC,iBAAiB,GAAG1B,OAAO,CAAC,MAAI;IAClC;IACA,IAAGY,GAAG,KAAKe,SAAS,GAAGlB,KAAK,CAACmB,GAAG,KAAKD,SAAS,GAAGlB,KAAK,CAACoB,IAAI,KAAKF,SAAS,EAAC;MACzE,IAAIG,eAAe,GAAG,EAAE;MACrB,MAAMC,SAAS,GAAGtB,KAAK,CAACoB,IAAI,CAACG,MAAM;MACnC,MAAMC,UAAU,GAAExB,KAAK,CAACoB,IAAI;MAC5BK,OAAO,CAACC,GAAG,CAACF,UAAU,CAAC;;MAEvB;MACA,MAAMG,iBAAiB,GAAGC,CAAC,IAAIA,CAAC,CAACC,KAAK;;MAEtC;MACA,MAAMC,WAAW,GAAGC,MAAM,CAACC,MAAM,CAACV,SAAS,CAAC,CAACH,GAAG,CAACQ,iBAAiB,CAAC;;MAEnE;MACA,MAAM,CAACM,QAAQ,EAACC,QAAQ,CAAC,GAAGzC,EAAE,CAAC0C,MAAM,CAACL,WAAW,CAAC;;MAElD;MACA;MACA;MACA,MAAMM,UAAU,GAAG3C,EAAE,CAAC4C,mBAAmB,CAAC,CAAC,CACtCC,MAAM,CAAC,CAACL,QAAQ,EAACC,QAAQ,CAAC,CAAC,CAC3BK,KAAK,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;;MAEjB;MACA;MACA;MACA,MAAMC,QAAQ,GAAG/C,EAAE,CAACE,eAAe,CAACF,EAAE,CAACgD,gBAAgB,CAAC;;MAExD;MACA,SAASC,QAAQA,CAACC,IAAI,EAAC;QACnB;QACAA,IAAI,GAAG7B,WAAW,CAAC6B,IAAI,CAAC;QACxB,IAAIC,KAAK,GAAGtB,SAAS,CAACuB,MAAM,CAACjB,CAAC,IAAEA,CAAC,CAACkB,KAAK,KAAGH,IAAI,CAAC;QAC/C,IAAGC,KAAK,KAAK1B,SAAS,GAAG0B,KAAK,CAACG,MAAM,GAAG,CAAC,EAAC;UACtC,OAAO,CAAC;QACZ;QACA1B,eAAe,GAAGuB,KAAK,CAAC,CAAC,CAAC,CAACI,UAAU;QACrC,OAAOrB,iBAAiB,CAACiB,KAAK,CAAC,CAAC,CAAC,CAAC;MACtC;MACA,SAASK,WAAWA,CAACN,IAAI,EAAC;QACtB,IAAId,KAAK,GAAGa,QAAQ,CAACC,IAAI,CAAC;QAC1B,IAAIO,GAAG,GAAGd,UAAU,CAACP,KAAK,CAAC;QAC3B,OAAOqB,GAAG;MACd;MAEA,SAASC,aAAaA,CAACvB,CAAC,EAAC;QACrB,OAAOY,QAAQ,CAACS,WAAW,CAACrB,CAAC,CAACwB,UAAU,CAACC,IAAI,CAAC,CAAC;MACnD;;MAEA;MACAlD,GAAG,CAACmD,SAAS,CAAC,GAAG,CAAC,CAACC,MAAM,CAAC,CAAC;;MAE3B;MACA;MACA,IAAIC,QAAQ,GAAGrD,GAAG,CAACsD,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,OAAO,EAAC,QAAQ,CAAC;MACrDF,QAAQ,CAACF,SAAS,CAAC,MAAM,CAAC,CAACT,MAAM,CAAC,QAAQ,CAAC,CACtCzB,IAAI,CAACpB,KAAK,CAACmB,GAAG,CAACwC,QAAQ,CAAC,CAACC,KAAK,CAAC,CAAC,CAChCH,MAAM,CAAC,MAAM,CAAC,CAACC,IAAI,CAAC,OAAO,EAAC,OAAO;MACpC;MAAA,CACCA,IAAI,CAAC,IAAI,EAAC9B,CAAC,IAAGd,WAAW,CAACc,CAAC,CAACwB,UAAU,CAACC,IAAI,CAAC,CAAC,CAC7CK,IAAI,CAAC,GAAG,EAAC9C,YAAY,CAAC,CACtB8C,IAAI,CAAC,MAAM,EAACP,aAAa,CAAC,CAC1BO,IAAI,CAAC,QAAQ,EAAC,OAAO,CAAC,CACtBA,IAAI,CAAC,cAAc,EAAC,GAAG,CAAC,CACxBG,EAAE,CAAC,WAAW,EAAC,CAACC,CAAC,EAAClC,CAAC,KAAG;QACnB,IAAIkB,KAAK,GAAGhC,WAAW,CAACc,CAAC,CAACwB,UAAU,CAACC,IAAI,CAAC;QAC1C;QACA,IAAGrD,KAAK,CAAC+D,YAAY,KAAKjB,KAAK,EAAC;UAC5B9C,KAAK,CAACgE,eAAe,CAAClB,KAAK,CAAC;QAChC;QACA,IAAImB,KAAK,GAAGrC,CAAC,CAACwB,UAAU,CAACC,IAAI;QAC7B,IAAIxB,KAAK,GAAGa,QAAQ,CAACuB,KAAK,CAAC;QAC3B,IAAIC,IAAI,GAAGD,KAAK,GAAG,OAAO,GACpB,mBAAmB,GAAG5C,eAAe,GAAG,OAAO,GAC/C,cAAc,GAAGQ,KAAK,GAAG,OAAO,GAChC,wBAAwB,GAAIA,KAAK,GAACR,eAAe,GAAE,OAAO;QAChEf,IAAI,CAAC6D,IAAI,CAACD,IAAI,CAAC;MACnB,CAAC,CAAC,CAACL,EAAE,CAAC,WAAW,EAAEC,CAAC,IAAG;QACnB;QACA9D,KAAK,CAACoE,OAAO,CAACC,aAAa,CAAC/D,IAAI,EAACwD,CAAC,CAAC;MACvC,CAAC,CAAC,CAACD,EAAE,CAAC,UAAU,EAAC,CAACC,CAAC,EAAClC,CAAC,KAAG;QACpB5B,KAAK,CAACgE,eAAe,CAAC,CAAC;QACvBhE,KAAK,CAACoE,OAAO,CAACE,QAAQ,CAAChE,IAAI,CAAC;MAChC,CAAC,CAAC;;MAGN;MACA;MACA;MACAmB,OAAO,CAACC,GAAG,CAAC,OAAO,CAAC;MAEpB,MAAM6C,QAAQ,GAAGvE,KAAK,CAACoB,IAAI,CAACoD,MAAM;MAClC/C,OAAO,CAACC,GAAG,CAAC,MAAM,CAAC;MACnB,MAAM+C,OAAO,GAAGhF,EAAE,CAACiF,GAAG,CAACH,QAAQ,CAACpD,GAAG,CAACS,CAAC,IAAEA,CAAC,CAACC,KAAK,CAAC,CAAC;MAChD,MAAM8C,SAAS,GAAGlF,EAAE,CAACmF,WAAW,CAAC,CAAC,CAC7BtC,MAAM,CAAC,CAAC,CAAC,EAACmC,OAAO,CAAC,CAAC,CACnBlC,KAAK,CAAC,CAAC,CAAC,EAAC/B,SAAS,CAAC,CAAC;MAEzBgD,QAAQ,CAACF,SAAS,CAAC,OAAO,CAAC,CAACC,MAAM,CAAC,CAAC;;MAEpC;MACA;;MAEA;MACA;MACA,MAAMsB,cAAc,GAAGpF,EAAE,CAACqF,WAAW,CAAC,CAAC,CAClCxC,MAAM,CAAC,CAAC,CAAC,EAACmC,OAAO,CAAC,CAAC,CACnBlC,KAAK,CAAC,CAAC,SAAS,EAAC,SAAS,CAAC,CAAC;MACjCiB,QAAQ,CAACF,SAAS,CAAC,OAAO,CAAC,CACtBlC,IAAI,CAACmD,QAAQ,CAAC,CAACX,KAAK,CAAC,CAAC,CACtBH,MAAM,CAAC,QAAQ,CAAC,CAACC,IAAI,CAAC,OAAO,EAAC,MAAM,CAAC,CACrCA,IAAI,CAAC,IAAI,EAAC9B,CAAC,IAAEA,CAAC,CAACmD,GAAG,CAAC,CACnBrB,IAAI,CAAC,IAAI,EAAC9B,CAAC,IAAGnB,UAAU,CAAC,CAACmB,CAAC,CAACoD,GAAG,EAACpD,CAAC,CAACqD,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC3CvB,IAAI,CAAC,IAAI,EAAC9B,CAAC,IAAGnB,UAAU,CAAC,CAACmB,CAAC,CAACoD,GAAG,EAACpD,CAAC,CAACqD,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC3CvB,IAAI,CAAC,GAAG,EAAC9B,CAAC,IAAE+C,SAAS,CAAC/C,CAAC,CAACC,KAAK,CAAC,CAAC,CAC/B6B,IAAI,CAAC,SAAS,EAAC,CAAC,CAAC,CACjBA,IAAI,CAAC,MAAM,EAAE9B,CAAC,IAAIiD,cAAc,CAACjD,CAAC,CAACC,KAAK,CAAC,CAAC,CAC1CgC,EAAE,CAAC,WAAW,EAAE,UAAUqB,KAAK,EAAEtD,CAAC,EAAE;QACjC;QACAtB,IAAI,CAAC6D,IAAI,CAAE,SAAQvC,CAAC,CAACuD,IAAK,cAAavD,CAAC,CAACC,KAAM,EAAC,CAAC,CAC5CuD,KAAK,CAAC,MAAM,EAAG,GAAEF,KAAK,CAACG,KAAM,IAAG,CAAC,CACjCD,KAAK,CAAC,KAAK,EAAG,GAAEF,KAAK,CAACI,KAAM,IAAG,CAAC,CAChCF,KAAK,CAAC,SAAS,EAAE,GAAG,CAAC;MAC9B,CAAC,CAAC,CACDvB,EAAE,CAAC,UAAU,EAAE,YAAY;QACxB;QACAvD,IAAI,CAAC8E,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC;MAC5B,CAAC,CAAC,CACDvB,EAAE,CAAC,WAAW,EAAE,CAACC,CAAC,EAAElC,CAAC,KAAK;QACvB,IAAI2D,QAAQ,GAAG3D,CAAC,CAACuD,IAAI;QACrB,IAAIK,SAAS,GAAG5D,CAAC,CAACC,KAAK;QACvB,IAAIqC,IAAI,GAAGqB,QAAQ,GAAG,OAAO,GAAG,cAAc,GAAGC,SAAS,GAAC,OAAO,GAChE,SAAS,GAAG5D,CAAC,CAACkB,KAAK,GAAG,OAAO;QAE/BxC,IAAI,CAAC6D,IAAI,CAACD,IAAI,CAAC;MACnB,CAAC,CAAC,CAACL,EAAE,CAAC,WAAW,EAAGC,CAAC,IAAK;QACtB9D,KAAK,CAACoE,OAAO,CAACC,aAAa,CAAC/D,IAAI,EAAEwD,CAAC,CAAC;MACxC,CAAC,CAAC,CAACD,EAAE,CAAC,UAAU,EAAE,CAACC,CAAC,EAAElC,CAAC,KAAK;QACxB5B,KAAK,CAACoE,OAAO,CAACE,QAAQ,CAAChE,IAAI,CAAC;MAChC,CAAC,CAAC;MACN;MACA,SAASmF,UAAUA,CAAA,EAAE;QACjB,IAAIC,MAAM,GAAGlC,QAAQ,CAACmC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;QACtC,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC3F,MAAM,GAAC,CAAC,EAAC,EAAE,CAAC;QAEvC,IAAI4F,OAAO,GAAGN,MAAM,CAACO,CAAC,GAAG,EAAE,GAAGP,MAAM,CAACrF,KAAK;QAC1C,MAAM6F,QAAQ,GAAGJ,IAAI,CAACC,GAAG,CAAC,CAAC1F,KAAK,GAAG2F,OAAO,IAAE,CAAC,EAAC,EAAE,CAAC;QACjD,MAAMG,UAAU,GAAGL,IAAI,CAACC,GAAG,CAACG,QAAQ,GAAC,CAAC,EAAC,EAAE,CAAC;QAC1C,IAAIE,OAAO,GAAGV,MAAM,CAACW,CAAC,GAAG,CAAC,GAACF,UAAU;QAErC,IAAIG,UAAU,GAAG,EAAE;QACnB;QACA,KAAI,IAAIC,KAAK,IAAI,CAAC,IAAI,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,CAAC,EAAC;UAClD,IAAIrD,GAAG,GAAG,CAAC,CAAC,GAACqD,KAAK,IAAEtE,QAAQ,GAAGsE,KAAK,GAACrE,QAAQ;UAC7C,IAAIsE,SAAS,GAAGpE,UAAU,CAACc,GAAG,CAAC;UAC/B,IAAIuD,KAAK,GAAGjE,QAAQ,CAACgE,SAAS,CAAC;UAC/B,IAAI5D,KAAK,GAAG;YACR,GAAG,EAAEoD,OAAO;YACZ,GAAG,EAAEI,OAAO;YACZ,OAAO,EAAElD,GAAG;YACZ,OAAO,EAACuD;UACZ,CAAC;UACD7D,KAAK,CAACsB,IAAI,GAAItB,KAAK,CAAC8D,KAAK,CAAEC,OAAO,CAAC,CAAC,CAAC;UAErCL,UAAU,CAACM,IAAI,CAAChE,KAAK,CAAC;UACtBwD,OAAO,IAAIP,SAAS;QACxB;QAEA1F,GAAG,CAACmD,SAAS,CAAC,aAAa,CAAC,CAACC,MAAM,CAAC,CAAC;QACrCpD,GAAG,CAACmD,SAAS,CAAC,aAAa,CAAC,CACvBlC,IAAI,CAACkF,UAAU,CAAC,CAAC1C,KAAK,CAAC,CAAC,CACxBH,MAAM,CAAC,MAAM,CAAC,CAACC,IAAI,CAAC,OAAO,EAAC,YAAY,CAAC,CACzCA,IAAI,CAAC,GAAG,EAAC9B,CAAC,IAAEA,CAAC,CAACqE,CAAC,CAAC,CAChBvC,IAAI,CAAC,GAAG,EAAC9B,CAAC,IAAEA,CAAC,CAACyE,CAAC,CAAC,CAChB3C,IAAI,CAAC,MAAM,EAAC9B,CAAC,IAAEA,CAAC,CAAC6E,KAAK,CAAC,CACvB/C,IAAI,CAAC,QAAQ,EAACmC,SAAS,CAAC,CACxBnC,IAAI,CAAC,OAAO,EAACwC,QAAQ,CAAC;QAE3B/F,GAAG,CAACmD,SAAS,CAAC,aAAa,CAAC,CAACC,MAAM,CAAC,CAAC;QACrC,MAAMsD,WAAW,GAAG;UAChB,GAAG,EAAEb,OAAO,GAAGE,QAAQ;UACvB,GAAG,EAAER,MAAM,CAACW,CAAC,GAAG;QAEpB,CAAC;QACDlG,GAAG,CAACmD,SAAS,CAAC,aAAa,CAAC,CACvBlC,IAAI,CAAC,CAACyF,WAAW,CAAC,CAACC,MAAM,CAACR,UAAU,CAAC,CAAC,CAAC1C,KAAK,CAAC,CAAC,CAC9CH,MAAM,CAAC,MAAM,CAAC,CAACC,IAAI,CAAC,OAAO,EAAC,YAAY,CAAC,CACzCA,IAAI,CAAC,GAAG,EAAC9B,CAAC,IAAEA,CAAC,CAACqE,CAAC,GAACC,QAAQ,GAAC,CAAC,CAAC,CAC3BxC,IAAI,CAAC,GAAG,EAAC9B,CAAC,IAAEA,CAAC,CAACyE,CAAC,GAACR,SAAS,GAAC,CAAC,GAAGM,UAAU,GAAC,CAAC,CAAC,CAC3CzC,IAAI,CAAC,WAAW,EAAC,CAAC9B,CAAC,EAACmF,CAAC,KAAKA,CAAC,IAAI,CAAC,GAAE,GAAG,GAACZ,UAAU,GAACA,UAAU,CAAC,CAC5DjC,IAAI,CAACtC,CAAC,IAAEA,CAAC,CAACsC,IAAI,CAAC;MACxB;MAEAuB,UAAU,CAAC,CAAC;MACZ,OAAOjC,QAAQ;IACnB;EACJ,CAAC,EAAC,CAACrD,GAAG,EAACH,KAAK,CAACmB,GAAG,EAACnB,KAAK,CAACoB,IAAI,CAAC,CAAC;;EAE7B;EACA;EACA;EACA7B,OAAO,CAAC,MAAI;IACR,IAAG0B,iBAAiB,KAAKC,SAAS,EAAC;MAAE;IAAO;;IAE5C;IACA,SAAS8F,MAAMA,CAAC9B,KAAK,EAAE;MACnB,MAAM;QAAC+B;MAAS,CAAC,GAAG/B,KAAK;MACzBjE,iBAAiB,CACZyC,IAAI,CAAC,WAAW,EAAEuD,SAAS,CAAC,CAC7BvD,IAAI,CAAC,cAAc,EAAE,CAAC,GAAGuD,SAAS,CAACC,CAAC,CAAC;IAC7C;IAEA,MAAMC,IAAI,GAAG1H,EAAE,CAAC0H,IAAI,CAAC,CAAC,CACjBtD,EAAE,CAAC,MAAM,EAAEmD,MAAM,CAAC;;IAEvB;IACA;IACA,SAASI,OAAOA,CAAClC,KAAK,EAAEtD,CAAC,EAAE;MACvBsD,KAAK,CAACmC,eAAe,CAAC,CAAC;MACvB,IAAG9G,QAAQ,EAAC;QACRU,iBAAiB,CAACqG,UAAU,CAAC,CAAC,CAACC,QAAQ,CAAC,GAAG,CAAC,CAACC,IAAI,CAC7CL,IAAI,CAACF,SAAS,EACdxH,EAAE,CAACgI,YAAY,CAAC9G,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC,EAC9BlB,EAAE,CAACiI,OAAO,CAACxC,KAAK,EAAC/E,GAAG,CAACwF,IAAI,CAAC,CAAC,CAC/B,CAAC;MAEL,CAAC,MACG;QACA;QACA,MAAM,CAAC,CAACgC,EAAE,EAAEC,EAAE,CAAC,EAAE,CAACC,EAAE,EAAEC,EAAE,CAAC,CAAC,GAAGlH,YAAY,CAAC8E,MAAM,CAAC9D,CAAC,CAAC;QACnD;QACAX,iBAAiB,CAACqG,UAAU,CAAC,CAAC,CAACC,QAAQ,CAAC,GAAG,CAAC,CAACC,IAAI,CAC7CL,IAAI,CAACF,SAAS,EACdxH,EAAE,CAACgI,YAAY,CACd9G,SAAS,CAACN,KAAK,GAAG,CAAC,EAAED,MAAM,GAAG,CAAC,CAAC,CAChC2H,KAAK,CAACjC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,GAAG,GAAGD,IAAI,CAACpB,GAAG,CAAC,CAACmD,EAAE,GAAGF,EAAE,IAAItH,KAAK,EAAE,CAACyH,EAAE,GAAGF,EAAE,IAAIxH,MAAM,CAAC,CAAC,CAAC,CACzEO,SAAS,CAAC,EAAEgH,EAAE,GAAGE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAED,EAAE,GAAGE,EAAE,CAAC,GAAG,CAAC,CAAC,EAC1CrI,EAAE,CAACiI,OAAO,CAACxC,KAAK,EAAE/E,GAAG,CAACwF,IAAI,CAAC,CAAC,CAChC,CAAC;MACL;MACA;MACA;MACApF,QAAQ,GAAG,CAACA,QAAQ;MACpB,IAAGA,QAAQ,EAAC;QACRP,KAAK,CAACgI,cAAc,CAACpG,CAAC,CAACwB,UAAU,CAACC,IAAI,CAAC;MAC3C,CAAC,MAAK;QACFrD,KAAK,CAACgI,cAAc,CAAC9G,SAAS,CAAC;MACnC;IACJ;IAGAD,iBAAiB,CAACqC,SAAS,CAAC,QAAQ,CAAC,CAChCI,IAAI,CAAC,QAAQ,EAAC,SAAS,CAAC;IAAA,CACxBG,EAAE,CAAC,OAAO,EAACuD,OAAO,CAAC;EAE5B,CAAC,EAAC,CAACnG,iBAAiB,CAAC,CAAC;;EAEtB;EACA;EACA;EACA;EACA;EACA1B,OAAO,CAAC,MAAI;IACR,IAAG0B,iBAAiB,KAAKC,SAAS,EAAC;MAC/B,MAAM+G,SAAS,GAAGjI,KAAK,CAAC+D,YAAY,KAAK7C,SAAS;MAClDD,iBAAiB,CAACqC,SAAS,CAAC,QAAQ,CAAC,CAChCI,IAAI,CAAC,SAAS,EAACuE,SAAS,GAAE,EAAE,GAAC,EAAE,CAAC,CAChCvE,IAAI,CAAC,aAAa,EAACuE,SAAS,GAAE,CAAC,GAAC,CAAC,CAAC;MACvC,IAAGA,SAAS,EAAC;QACThH,iBAAiB,CAACiH,MAAM,CAAC,GAAG,GAAClI,KAAK,CAAC+D,YAAY,CAAC,CAC3CL,IAAI,CAAC,SAAS,EAAC,CAAC,CAAC,CACjBA,IAAI,CAAC,aAAa,EAAC,CAAC,CAAC;MAC9B;IACJ;EACJ,CAAC,EAAC,CAACzC,iBAAiB,EAACjB,KAAK,CAAC+D,YAAY,CAAC,CAAC;EAEzC,oBACIjE,OAAA;IACIqI,SAAS,EAAE,cAAe;IAC1B/C,KAAK,EAAE;MAAC,QAAQ,EAAC,KAAK;MAAC,OAAO,EAAC;IAAK,CAAE;IACtCgD,GAAG,EAAElI;EAAY;IAAAmI,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACf,CAAC;AAEf;AAACvI,EAAA,CA3TuBF,QAAQ;EAAA,QAMOP,YAAY;AAAA;AAAAiJ,EAAA,GAN3B1I,QAAQ;AAAA,IAAA0I,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}